{"uid":"733e24fdd9f2c81b","name":"3.缺少courseId参数","fullName":"testcase.Single.CourseManagement.test_course_findbyid.TestCourseFindById#test_course_findbyid","historyId":"6399aecd89b20748d044ead792e1c087","time":{"start":1750810838915,"stop":1750810839026,"duration":111},"description":"\n        测试根据课程ID查询课程接口\n        验证通过课程ID获取特定课程信息的功能，包括有效ID、无效ID和权限验证\n        ","descriptionHtml":"<pre><code>    测试根据课程ID查询课程接口\n    验证通过课程ID获取特定课程信息的功能，包括有效ID、无效ID和权限验证\n</code></pre>\n","status":"broken","statusMessage":"UnboundLocalError: cannot access local variable 'validation' where it is not associated with a value","statusTrace":"self = <Response [400]>, kwargs = {}\n\n    def json(self, **kwargs):\n        r\"\"\"Returns the json-encoded content of a response, if any.\n    \n        :param \\*\\*kwargs: Optional arguments that ``json.loads`` takes.\n        :raises requests.exceptions.JSONDecodeError: If the response body does not\n            contain valid json.\n        \"\"\"\n    \n        if not self.encoding and self.content and len(self.content) > 3:\n            # No encoding set. JSON RFC 4627 section 3 states we should expect\n            # UTF-8, -16 or -32. Detect which one to use; If the detection or\n            # decoding fails, fall back to `self.text` (using charset_normalizer to make\n            # a best guess).\n            encoding = guess_json_utf(self.content)\n            if encoding is not None:\n                try:\n                    return complexjson.loads(self.content.decode(encoding), **kwargs)\n                except UnicodeDecodeError:\n                    # Wrong UTF codec detected; usually because it's not UTF-8\n                    # but some other 8-bit codec.  This is an RFC violation,\n                    # and the server didn't bother to tell us what codec *was*\n                    # used.\n                    pass\n                except JSONDecodeError as e:\n                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)\n    \n        try:\n>           return complexjson.loads(self.text, **kwargs)\n\n..\\..\\Pyproject\\testProject\\venv\\Lib\\site-packages\\requests\\models.py:974: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nC:\\Users\\seeki\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\json\\__init__.py:346: in loads\n    return _default_decoder.decode(s)\nC:\\Users\\seeki\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\json\\decoder.py:337: in decode\n    obj, end = self.raw_decode(s, idx=_w(s, 0).end())\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <json.decoder.JSONDecoder object at 0x000001C323AB5790>\ns = '<!doctype html><html lang=\"en\"><head><title>HTTP Status 400 – Bad Request</title><style type=\"text/css\">body {font-fa...uest message framing, or deceptive request routing).</p><hr class=\"line\" /><h3>Apache Tomcat/8.5.63</h3></body></html>'\nidx = 0\n\n    def raw_decode(self, s, idx=0):\n        \"\"\"Decode a JSON document from ``s`` (a ``str`` beginning with\n        a JSON document) and return a 2-tuple of the Python\n        representation and the index in ``s`` where the document ended.\n    \n        This can be used to decode a JSON document from a string that may\n        have extraneous data at the end.\n    \n        \"\"\"\n        try:\n            obj, end = self.scan_once(s, idx)\n        except StopIteration as err:\n>           raise JSONDecodeError(\"Expecting value\", s, err.value) from None\nE           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)\n\nC:\\Users\\seeki\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\json\\decoder.py:355: JSONDecodeError\n\nDuring handling of the above exception, another exception occurred:\n\nself = <base.apiutil.RequestBase object at 0x000001C35916AFF0>\nbase_info = {'api_name': '根据课程ID查询课程', 'header': {'Authorization': '${get_extract_data(token)}', 'Cookie': '${get_extract_data(cookie)}'}, 'method': 'GET', 'url': '/ssm_web/courseContent/findCourseByCourseId'}\ntest_case = {'params': {}}\n\n    def specification_yaml(self, base_info, test_case):\n        \"\"\"\n        接口请求处理基本方法\n        核心枢纽：将 YAML 中的 baseInfo 和 testCase 组合成可执行的测试步骤。\n        流程控制：依次处理参数、发送请求(run_main，send_request)、提取数据、执行断言，是类的主入口方法。\n        :param base_info: yaml文件里面的baseInfo\n        :param test_case: yaml文件里面的testCase\n        :return:\n        \"\"\"\n        try:\n            params_type = ['data', 'json', 'params']\n            # 根据接口配置选择host\n            url_host = self.get_host(base_info, test_case)\n            test_case.pop('use_mock', None)\n            base_info.pop('use_mock', None)\n            api_name = base_info['api_name']\n            allure.attach(api_name, f'接口名称：{api_name}', allure.attachment_type.TEXT)\n            url = url_host + base_info['url']\n            allure.attach(api_name, f'接口地址：{url}', allure.attachment_type.TEXT)\n            method = base_info['method']\n            allure.attach(api_name, f'请求方法：{method}', allure.attachment_type.TEXT)\n            # 处理请求头：支持testCase级别完全覆盖baseInfo的header\n            if 'header' in test_case:\n                # 如果testCase中有header，则完全使用testCase的header\n                header = self.replace_load(test_case.pop('header'))\n            elif 'header' in base_info:\n                # 否则使用baseInfo中的header\n                header = self.replace_load(base_info['header'])\n            else:\n                header = {}\n    \n            allure.attach(api_name, f'请求头：{header}', allure.attachment_type.TEXT)\n            # 处理cookie\n            cookie = None\n            if base_info.get('cookies') is not None:\n                cookie = eval(self.replace_load(base_info['cookies']))\n            # pop：字典 删除case_name键值对并返回case_name的值\n            case_name = test_case.pop('case_name')\n            allure.attach(api_name, f'测试用例名称：{case_name}', allure.attachment_type.TEXT)\n            # 处理断言\n            val = self.replace_load(test_case.get('validation'))\n            # replace_load将validation从列表转换成了字符串，所以可以使用replace函数\n            test_case['validation'] = val\n            # validation = eval(test_case.pop('validation'))  为了断言bool值，json和python的bool大小写不一样，改成下面代码\n            # validation = eval((test_case.pop('validation')).replace('true', 'True').replace('false', 'False'))\n            val = test_case.get('validation')\n            test_case.pop('validation')\n            # 处理参数提取\n            extract = test_case.pop('extract', None)\n            extract_list = test_case.pop('extract_list', None)\n            # 处理接口的请求参数\n            for key, value in test_case.items():\n                if key in params_type:\n                    test_case[key] = self.replace_load(value)\n    \n            # 处理文件上传接口\n            file, files = test_case.pop('files', None), None\n            if file is not None:\n                for fk, fv in file.items():\n                    allure.attach(json.dumps(file), '导入文件')\n                    files = {fk: open(fv, mode='rb')}\n            # run_main ：核心是发送请求。  传入的参数包含有base_info，和test_case中的'data:{xxx}'\n            res = self.run.run_main(name=api_name, url=url, case_name=case_name, header=header, method=method,\n                                    file=files, cookies=cookie, **test_case)\n            if extract is not None:  # extract : {'token': '$.token'}\n                self.extract_data(extract, res)\n            if extract_list is not None:\n                self.extract_data_list(extract_list, res.text)\n    \n            status_code = res.status_code\n            # 无论 Content-Type 是什么，直接尝试解析 JSON\n            try:\n>               res_json = res.json()  # 强制尝试解析响应内容\n\nbase\\apiutil.py:163: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <Response [400]>, kwargs = {}\n\n    def json(self, **kwargs):\n        r\"\"\"Returns the json-encoded content of a response, if any.\n    \n        :param \\*\\*kwargs: Optional arguments that ``json.loads`` takes.\n        :raises requests.exceptions.JSONDecodeError: If the response body does not\n            contain valid json.\n        \"\"\"\n    \n        if not self.encoding and self.content and len(self.content) > 3:\n            # No encoding set. JSON RFC 4627 section 3 states we should expect\n            # UTF-8, -16 or -32. Detect which one to use; If the detection or\n            # decoding fails, fall back to `self.text` (using charset_normalizer to make\n            # a best guess).\n            encoding = guess_json_utf(self.content)\n            if encoding is not None:\n                try:\n                    return complexjson.loads(self.content.decode(encoding), **kwargs)\n                except UnicodeDecodeError:\n                    # Wrong UTF codec detected; usually because it's not UTF-8\n                    # but some other 8-bit codec.  This is an RFC violation,\n                    # and the server didn't bother to tell us what codec *was*\n                    # used.\n                    pass\n                except JSONDecodeError as e:\n                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)\n    \n        try:\n            return complexjson.loads(self.text, **kwargs)\n        except JSONDecodeError as e:\n            # Catch JSON-related errors and raise as requests.JSONDecodeError\n            # This aliases json.JSONDecodeError and simplejson.JSONDecodeError\n>           raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)\nE           requests.exceptions.JSONDecodeError: Expecting value: line 1 column 1 (char 0)\n\n..\\..\\Pyproject\\testProject\\venv\\Lib\\site-packages\\requests\\models.py:978: JSONDecodeError\n\nDuring handling of the above exception, another exception occurred:\n\nself = <testcase.Single.CourseManagement.test_course_findbyid.TestCourseFindById object at 0x000001C35903ACC0>\nbase_info = {'api_name': '根据课程ID查询课程', 'header': {'Authorization': '${get_extract_data(token)}', 'Cookie': '${get_extract_data(cookie)}'}, 'method': 'GET', 'url': '/ssm_web/courseContent/findCourseByCourseId'}\ntestcase = {'params': {}}\n\n    @allure.story(next(c_id) + \"根据课程ID查询课程\")\n    @pytest.mark.run(order=11)\n    @pytest.mark.parametrize('base_info,testcase', get_testcase_yaml(\"./testcase/Single/CourseManagement/course_findbyid_data.yaml\"))\n    def test_course_findbyid(self, base_info, testcase):\n        \"\"\"\n        测试根据课程ID查询课程接口\n        验证通过课程ID获取特定课程信息的功能，包括有效ID、无效ID和权限验证\n        \"\"\"\n        allure.dynamic.title(testcase['case_name'])\n        logs.info(f\"开始执行测试用例: {testcase['case_name']}\")\n>       RequestBase().specification_yaml(base_info, testcase)\n\ntestcase\\Single\\CourseManagement\\test_course_findbyid.py:28: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nbase\\apiutil.py:193: in specification_yaml\n    raise e\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <base.apiutil.RequestBase object at 0x000001C35916AFF0>\nbase_info = {'api_name': '根据课程ID查询课程', 'header': {'Authorization': '${get_extract_data(token)}', 'Cookie': '${get_extract_data(cookie)}'}, 'method': 'GET', 'url': '/ssm_web/courseContent/findCourseByCourseId'}\ntest_case = {'params': {}}\n\n    def specification_yaml(self, base_info, test_case):\n        \"\"\"\n        接口请求处理基本方法\n        核心枢纽：将 YAML 中的 baseInfo 和 testCase 组合成可执行的测试步骤。\n        流程控制：依次处理参数、发送请求(run_main，send_request)、提取数据、执行断言，是类的主入口方法。\n        :param base_info: yaml文件里面的baseInfo\n        :param test_case: yaml文件里面的testCase\n        :return:\n        \"\"\"\n        try:\n            params_type = ['data', 'json', 'params']\n            # 根据接口配置选择host\n            url_host = self.get_host(base_info, test_case)\n            test_case.pop('use_mock', None)\n            base_info.pop('use_mock', None)\n            api_name = base_info['api_name']\n            allure.attach(api_name, f'接口名称：{api_name}', allure.attachment_type.TEXT)\n            url = url_host + base_info['url']\n            allure.attach(api_name, f'接口地址：{url}', allure.attachment_type.TEXT)\n            method = base_info['method']\n            allure.attach(api_name, f'请求方法：{method}', allure.attachment_type.TEXT)\n            # 处理请求头：支持testCase级别完全覆盖baseInfo的header\n            if 'header' in test_case:\n                # 如果testCase中有header，则完全使用testCase的header\n                header = self.replace_load(test_case.pop('header'))\n            elif 'header' in base_info:\n                # 否则使用baseInfo中的header\n                header = self.replace_load(base_info['header'])\n            else:\n                header = {}\n    \n            allure.attach(api_name, f'请求头：{header}', allure.attachment_type.TEXT)\n            # 处理cookie\n            cookie = None\n            if base_info.get('cookies') is not None:\n                cookie = eval(self.replace_load(base_info['cookies']))\n            # pop：字典 删除case_name键值对并返回case_name的值\n            case_name = test_case.pop('case_name')\n            allure.attach(api_name, f'测试用例名称：{case_name}', allure.attachment_type.TEXT)\n            # 处理断言\n            val = self.replace_load(test_case.get('validation'))\n            # replace_load将validation从列表转换成了字符串，所以可以使用replace函数\n            test_case['validation'] = val\n            # validation = eval(test_case.pop('validation'))  为了断言bool值，json和python的bool大小写不一样，改成下面代码\n            # validation = eval((test_case.pop('validation')).replace('true', 'True').replace('false', 'False'))\n            val = test_case.get('validation')\n            test_case.pop('validation')\n            # 处理参数提取\n            extract = test_case.pop('extract', None)\n            extract_list = test_case.pop('extract_list', None)\n            # 处理接口的请求参数\n            for key, value in test_case.items():\n                if key in params_type:\n                    test_case[key] = self.replace_load(value)\n    \n            # 处理文件上传接口\n            file, files = test_case.pop('files', None), None\n            if file is not None:\n                for fk, fv in file.items():\n                    allure.attach(json.dumps(file), '导入文件')\n                    files = {fk: open(fv, mode='rb')}\n            # run_main ：核心是发送请求。  传入的参数包含有base_info，和test_case中的'data:{xxx}'\n            res = self.run.run_main(name=api_name, url=url, case_name=case_name, header=header, method=method,\n                                    file=files, cookies=cookie, **test_case)\n            if extract is not None:  # extract : {'token': '$.token'}\n                self.extract_data(extract, res)\n            if extract_list is not None:\n                self.extract_data_list(extract_list, res.text)\n    \n            status_code = res.status_code\n            # 无论 Content-Type 是什么，直接尝试解析 JSON\n            try:\n                res_json = res.json()  # 强制尝试解析响应内容\n                # 附加 JSON 响应到报告\n                allure.attach(\n                    self.allure_attach_response(res_json),\n                    '接口响应信息',\n                    allure.attachment_type.TEXT\n                )\n                validation = eval((self.replace_load(val)).replace('true', 'True').replace('false', 'False'))\n                # 处理断言（包含 JSON 数据和状态码）\n                self.asserts.assert_result(validation, res_json, status_code)\n    \n            except (JSONDecodeError, ValueError) as e:  # 捕获 JSON 解析异常\n                # 记录错误日志（明确提示内容非JSON）\n                logs.error(f'响应非JSON格式，解析失败: {e}，原始内容: {res.text[:200]}...')\n    \n                # 附加原始响应内容到报告（确保非JSON也能展示）\n                allure.attach(\n                    res.text if res.text else res.content.decode('utf-8', errors='ignore'),\n                    '接口响应原始内容',\n                    allure.attachment_type.TEXT\n                )\n    \n                # 仅验证状态码（根据业务需求，可扩展其他非JSON断言。比如验证码接口返回的是图片）\n                self.asserts.assert_result(\n>                   validation,\n                    {'status_code': status_code},  # 构造仅包含状态码的模拟数据\n                    status_code\n                )\nE               UnboundLocalError: cannot access local variable 'validation' where it is not associated with a value\n\nbase\\apiutil.py:187: UnboundLocalError","flaky":false,"newFailed":false,"newBroken":false,"newPassed":false,"retriesCount":0,"retriesStatusChange":false,"beforeStages":[{"name":"clear_extract","time":{"start":1750810825739,"stop":1750810825739,"duration":0},"status":"passed","steps":[],"attachments":[],"parameters":[],"attachmentsCount":0,"shouldDisplayMessage":false,"attachmentStep":false,"stepsCount":0,"hasContent":false},{"name":"setup_fixture","time":{"start":1750810825739,"stop":1750810825739,"duration":0},"status":"passed","steps":[],"attachments":[],"parameters":[],"attachmentsCount":0,"shouldDisplayMessage":false,"attachmentStep":false,"stepsCount":0,"hasContent":false},{"name":"datadb_init","time":{"start":1750810825739,"stop":1750810825739,"duration":0},"status":"passed","steps":[],"attachments":[],"parameters":[],"attachmentsCount":0,"shouldDisplayMessage":false,"attachmentStep":false,"stepsCount":0,"hasContent":false},{"name":"system_login","time":{"start":1750810825739,"stop":1750810825861,"duration":122},"status":"passed","steps":[],"attachments":[{"uid":"4e5c8babd28f3853","name":"接口名称：用户登录","source":"4e5c8babd28f3853.txt","type":"text/plain","size":12},{"uid":"c9747c718cba19fe","name":"接口地址：http://47.115.225.121:8080/ssm_web/user/login","source":"c9747c718cba19fe.txt","type":"text/plain","size":12},{"uid":"e2885d4dc61c91c7","name":"请求方法：POST","source":"e2885d4dc61c91c7.txt","type":"text/plain","size":12},{"uid":"a3e14cb2742d9620","name":"请求头：{}","source":"a3e14cb2742d9620.txt","type":"text/plain","size":12},{"uid":"f2c9d4d85a586e33","name":"测试用例名称：登录成功","source":"f2c9d4d85a586e33.txt","type":"text/plain","size":12},{"uid":"bbe308b8e527aa08","name":"请求参数","source":"bbe308b8e527aa08.txt","type":"text/plain","size":58},{"uid":"9088e3eb7c12fd9c","name":"接口响应信息","source":"9088e3eb7c12fd9c.txt","type":"text/plain","size":675},{"uid":"7f227e425289ffa0","name":"响应文本断言结果：成功","source":"7f227e425289ffa0.txt","type":"text/plain","size":62},{"uid":"fae76b796458234d","name":"响应代码断言结果:成功","source":"fae76b796458234d.txt","type":"text/plain","size":37}],"parameters":[],"attachmentsCount":9,"shouldDisplayMessage":false,"attachmentStep":false,"stepsCount":0,"hasContent":true},{"name":"start_test_and_end","time":{"start":1750810838915,"stop":1750810838915,"duration":0},"status":"passed","steps":[],"attachments":[],"parameters":[],"attachmentsCount":0,"shouldDisplayMessage":false,"attachmentStep":false,"stepsCount":0,"hasContent":false}],"testStage":{"description":"\n        测试根据课程ID查询课程接口\n        验证通过课程ID获取特定课程信息的功能，包括有效ID、无效ID和权限验证\n        ","status":"broken","statusMessage":"UnboundLocalError: cannot access local variable 'validation' where it is not associated with a value","statusTrace":"self = <Response [400]>, kwargs = {}\n\n    def json(self, **kwargs):\n        r\"\"\"Returns the json-encoded content of a response, if any.\n    \n        :param \\*\\*kwargs: Optional arguments that ``json.loads`` takes.\n        :raises requests.exceptions.JSONDecodeError: If the response body does not\n            contain valid json.\n        \"\"\"\n    \n        if not self.encoding and self.content and len(self.content) > 3:\n            # No encoding set. JSON RFC 4627 section 3 states we should expect\n            # UTF-8, -16 or -32. Detect which one to use; If the detection or\n            # decoding fails, fall back to `self.text` (using charset_normalizer to make\n            # a best guess).\n            encoding = guess_json_utf(self.content)\n            if encoding is not None:\n                try:\n                    return complexjson.loads(self.content.decode(encoding), **kwargs)\n                except UnicodeDecodeError:\n                    # Wrong UTF codec detected; usually because it's not UTF-8\n                    # but some other 8-bit codec.  This is an RFC violation,\n                    # and the server didn't bother to tell us what codec *was*\n                    # used.\n                    pass\n                except JSONDecodeError as e:\n                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)\n    \n        try:\n>           return complexjson.loads(self.text, **kwargs)\n\n..\\..\\Pyproject\\testProject\\venv\\Lib\\site-packages\\requests\\models.py:974: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nC:\\Users\\seeki\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\json\\__init__.py:346: in loads\n    return _default_decoder.decode(s)\nC:\\Users\\seeki\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\json\\decoder.py:337: in decode\n    obj, end = self.raw_decode(s, idx=_w(s, 0).end())\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <json.decoder.JSONDecoder object at 0x000001C323AB5790>\ns = '<!doctype html><html lang=\"en\"><head><title>HTTP Status 400 – Bad Request</title><style type=\"text/css\">body {font-fa...uest message framing, or deceptive request routing).</p><hr class=\"line\" /><h3>Apache Tomcat/8.5.63</h3></body></html>'\nidx = 0\n\n    def raw_decode(self, s, idx=0):\n        \"\"\"Decode a JSON document from ``s`` (a ``str`` beginning with\n        a JSON document) and return a 2-tuple of the Python\n        representation and the index in ``s`` where the document ended.\n    \n        This can be used to decode a JSON document from a string that may\n        have extraneous data at the end.\n    \n        \"\"\"\n        try:\n            obj, end = self.scan_once(s, idx)\n        except StopIteration as err:\n>           raise JSONDecodeError(\"Expecting value\", s, err.value) from None\nE           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)\n\nC:\\Users\\seeki\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\json\\decoder.py:355: JSONDecodeError\n\nDuring handling of the above exception, another exception occurred:\n\nself = <base.apiutil.RequestBase object at 0x000001C35916AFF0>\nbase_info = {'api_name': '根据课程ID查询课程', 'header': {'Authorization': '${get_extract_data(token)}', 'Cookie': '${get_extract_data(cookie)}'}, 'method': 'GET', 'url': '/ssm_web/courseContent/findCourseByCourseId'}\ntest_case = {'params': {}}\n\n    def specification_yaml(self, base_info, test_case):\n        \"\"\"\n        接口请求处理基本方法\n        核心枢纽：将 YAML 中的 baseInfo 和 testCase 组合成可执行的测试步骤。\n        流程控制：依次处理参数、发送请求(run_main，send_request)、提取数据、执行断言，是类的主入口方法。\n        :param base_info: yaml文件里面的baseInfo\n        :param test_case: yaml文件里面的testCase\n        :return:\n        \"\"\"\n        try:\n            params_type = ['data', 'json', 'params']\n            # 根据接口配置选择host\n            url_host = self.get_host(base_info, test_case)\n            test_case.pop('use_mock', None)\n            base_info.pop('use_mock', None)\n            api_name = base_info['api_name']\n            allure.attach(api_name, f'接口名称：{api_name}', allure.attachment_type.TEXT)\n            url = url_host + base_info['url']\n            allure.attach(api_name, f'接口地址：{url}', allure.attachment_type.TEXT)\n            method = base_info['method']\n            allure.attach(api_name, f'请求方法：{method}', allure.attachment_type.TEXT)\n            # 处理请求头：支持testCase级别完全覆盖baseInfo的header\n            if 'header' in test_case:\n                # 如果testCase中有header，则完全使用testCase的header\n                header = self.replace_load(test_case.pop('header'))\n            elif 'header' in base_info:\n                # 否则使用baseInfo中的header\n                header = self.replace_load(base_info['header'])\n            else:\n                header = {}\n    \n            allure.attach(api_name, f'请求头：{header}', allure.attachment_type.TEXT)\n            # 处理cookie\n            cookie = None\n            if base_info.get('cookies') is not None:\n                cookie = eval(self.replace_load(base_info['cookies']))\n            # pop：字典 删除case_name键值对并返回case_name的值\n            case_name = test_case.pop('case_name')\n            allure.attach(api_name, f'测试用例名称：{case_name}', allure.attachment_type.TEXT)\n            # 处理断言\n            val = self.replace_load(test_case.get('validation'))\n            # replace_load将validation从列表转换成了字符串，所以可以使用replace函数\n            test_case['validation'] = val\n            # validation = eval(test_case.pop('validation'))  为了断言bool值，json和python的bool大小写不一样，改成下面代码\n            # validation = eval((test_case.pop('validation')).replace('true', 'True').replace('false', 'False'))\n            val = test_case.get('validation')\n            test_case.pop('validation')\n            # 处理参数提取\n            extract = test_case.pop('extract', None)\n            extract_list = test_case.pop('extract_list', None)\n            # 处理接口的请求参数\n            for key, value in test_case.items():\n                if key in params_type:\n                    test_case[key] = self.replace_load(value)\n    \n            # 处理文件上传接口\n            file, files = test_case.pop('files', None), None\n            if file is not None:\n                for fk, fv in file.items():\n                    allure.attach(json.dumps(file), '导入文件')\n                    files = {fk: open(fv, mode='rb')}\n            # run_main ：核心是发送请求。  传入的参数包含有base_info，和test_case中的'data:{xxx}'\n            res = self.run.run_main(name=api_name, url=url, case_name=case_name, header=header, method=method,\n                                    file=files, cookies=cookie, **test_case)\n            if extract is not None:  # extract : {'token': '$.token'}\n                self.extract_data(extract, res)\n            if extract_list is not None:\n                self.extract_data_list(extract_list, res.text)\n    \n            status_code = res.status_code\n            # 无论 Content-Type 是什么，直接尝试解析 JSON\n            try:\n>               res_json = res.json()  # 强制尝试解析响应内容\n\nbase\\apiutil.py:163: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <Response [400]>, kwargs = {}\n\n    def json(self, **kwargs):\n        r\"\"\"Returns the json-encoded content of a response, if any.\n    \n        :param \\*\\*kwargs: Optional arguments that ``json.loads`` takes.\n        :raises requests.exceptions.JSONDecodeError: If the response body does not\n            contain valid json.\n        \"\"\"\n    \n        if not self.encoding and self.content and len(self.content) > 3:\n            # No encoding set. JSON RFC 4627 section 3 states we should expect\n            # UTF-8, -16 or -32. Detect which one to use; If the detection or\n            # decoding fails, fall back to `self.text` (using charset_normalizer to make\n            # a best guess).\n            encoding = guess_json_utf(self.content)\n            if encoding is not None:\n                try:\n                    return complexjson.loads(self.content.decode(encoding), **kwargs)\n                except UnicodeDecodeError:\n                    # Wrong UTF codec detected; usually because it's not UTF-8\n                    # but some other 8-bit codec.  This is an RFC violation,\n                    # and the server didn't bother to tell us what codec *was*\n                    # used.\n                    pass\n                except JSONDecodeError as e:\n                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)\n    \n        try:\n            return complexjson.loads(self.text, **kwargs)\n        except JSONDecodeError as e:\n            # Catch JSON-related errors and raise as requests.JSONDecodeError\n            # This aliases json.JSONDecodeError and simplejson.JSONDecodeError\n>           raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)\nE           requests.exceptions.JSONDecodeError: Expecting value: line 1 column 1 (char 0)\n\n..\\..\\Pyproject\\testProject\\venv\\Lib\\site-packages\\requests\\models.py:978: JSONDecodeError\n\nDuring handling of the above exception, another exception occurred:\n\nself = <testcase.Single.CourseManagement.test_course_findbyid.TestCourseFindById object at 0x000001C35903ACC0>\nbase_info = {'api_name': '根据课程ID查询课程', 'header': {'Authorization': '${get_extract_data(token)}', 'Cookie': '${get_extract_data(cookie)}'}, 'method': 'GET', 'url': '/ssm_web/courseContent/findCourseByCourseId'}\ntestcase = {'params': {}}\n\n    @allure.story(next(c_id) + \"根据课程ID查询课程\")\n    @pytest.mark.run(order=11)\n    @pytest.mark.parametrize('base_info,testcase', get_testcase_yaml(\"./testcase/Single/CourseManagement/course_findbyid_data.yaml\"))\n    def test_course_findbyid(self, base_info, testcase):\n        \"\"\"\n        测试根据课程ID查询课程接口\n        验证通过课程ID获取特定课程信息的功能，包括有效ID、无效ID和权限验证\n        \"\"\"\n        allure.dynamic.title(testcase['case_name'])\n        logs.info(f\"开始执行测试用例: {testcase['case_name']}\")\n>       RequestBase().specification_yaml(base_info, testcase)\n\ntestcase\\Single\\CourseManagement\\test_course_findbyid.py:28: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nbase\\apiutil.py:193: in specification_yaml\n    raise e\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <base.apiutil.RequestBase object at 0x000001C35916AFF0>\nbase_info = {'api_name': '根据课程ID查询课程', 'header': {'Authorization': '${get_extract_data(token)}', 'Cookie': '${get_extract_data(cookie)}'}, 'method': 'GET', 'url': '/ssm_web/courseContent/findCourseByCourseId'}\ntest_case = {'params': {}}\n\n    def specification_yaml(self, base_info, test_case):\n        \"\"\"\n        接口请求处理基本方法\n        核心枢纽：将 YAML 中的 baseInfo 和 testCase 组合成可执行的测试步骤。\n        流程控制：依次处理参数、发送请求(run_main，send_request)、提取数据、执行断言，是类的主入口方法。\n        :param base_info: yaml文件里面的baseInfo\n        :param test_case: yaml文件里面的testCase\n        :return:\n        \"\"\"\n        try:\n            params_type = ['data', 'json', 'params']\n            # 根据接口配置选择host\n            url_host = self.get_host(base_info, test_case)\n            test_case.pop('use_mock', None)\n            base_info.pop('use_mock', None)\n            api_name = base_info['api_name']\n            allure.attach(api_name, f'接口名称：{api_name}', allure.attachment_type.TEXT)\n            url = url_host + base_info['url']\n            allure.attach(api_name, f'接口地址：{url}', allure.attachment_type.TEXT)\n            method = base_info['method']\n            allure.attach(api_name, f'请求方法：{method}', allure.attachment_type.TEXT)\n            # 处理请求头：支持testCase级别完全覆盖baseInfo的header\n            if 'header' in test_case:\n                # 如果testCase中有header，则完全使用testCase的header\n                header = self.replace_load(test_case.pop('header'))\n            elif 'header' in base_info:\n                # 否则使用baseInfo中的header\n                header = self.replace_load(base_info['header'])\n            else:\n                header = {}\n    \n            allure.attach(api_name, f'请求头：{header}', allure.attachment_type.TEXT)\n            # 处理cookie\n            cookie = None\n            if base_info.get('cookies') is not None:\n                cookie = eval(self.replace_load(base_info['cookies']))\n            # pop：字典 删除case_name键值对并返回case_name的值\n            case_name = test_case.pop('case_name')\n            allure.attach(api_name, f'测试用例名称：{case_name}', allure.attachment_type.TEXT)\n            # 处理断言\n            val = self.replace_load(test_case.get('validation'))\n            # replace_load将validation从列表转换成了字符串，所以可以使用replace函数\n            test_case['validation'] = val\n            # validation = eval(test_case.pop('validation'))  为了断言bool值，json和python的bool大小写不一样，改成下面代码\n            # validation = eval((test_case.pop('validation')).replace('true', 'True').replace('false', 'False'))\n            val = test_case.get('validation')\n            test_case.pop('validation')\n            # 处理参数提取\n            extract = test_case.pop('extract', None)\n            extract_list = test_case.pop('extract_list', None)\n            # 处理接口的请求参数\n            for key, value in test_case.items():\n                if key in params_type:\n                    test_case[key] = self.replace_load(value)\n    \n            # 处理文件上传接口\n            file, files = test_case.pop('files', None), None\n            if file is not None:\n                for fk, fv in file.items():\n                    allure.attach(json.dumps(file), '导入文件')\n                    files = {fk: open(fv, mode='rb')}\n            # run_main ：核心是发送请求。  传入的参数包含有base_info，和test_case中的'data:{xxx}'\n            res = self.run.run_main(name=api_name, url=url, case_name=case_name, header=header, method=method,\n                                    file=files, cookies=cookie, **test_case)\n            if extract is not None:  # extract : {'token': '$.token'}\n                self.extract_data(extract, res)\n            if extract_list is not None:\n                self.extract_data_list(extract_list, res.text)\n    \n            status_code = res.status_code\n            # 无论 Content-Type 是什么，直接尝试解析 JSON\n            try:\n                res_json = res.json()  # 强制尝试解析响应内容\n                # 附加 JSON 响应到报告\n                allure.attach(\n                    self.allure_attach_response(res_json),\n                    '接口响应信息',\n                    allure.attachment_type.TEXT\n                )\n                validation = eval((self.replace_load(val)).replace('true', 'True').replace('false', 'False'))\n                # 处理断言（包含 JSON 数据和状态码）\n                self.asserts.assert_result(validation, res_json, status_code)\n    \n            except (JSONDecodeError, ValueError) as e:  # 捕获 JSON 解析异常\n                # 记录错误日志（明确提示内容非JSON）\n                logs.error(f'响应非JSON格式，解析失败: {e}，原始内容: {res.text[:200]}...')\n    \n                # 附加原始响应内容到报告（确保非JSON也能展示）\n                allure.attach(\n                    res.text if res.text else res.content.decode('utf-8', errors='ignore'),\n                    '接口响应原始内容',\n                    allure.attachment_type.TEXT\n                )\n    \n                # 仅验证状态码（根据业务需求，可扩展其他非JSON断言。比如验证码接口返回的是图片）\n                self.asserts.assert_result(\n>                   validation,\n                    {'status_code': status_code},  # 构造仅包含状态码的模拟数据\n                    status_code\n                )\nE               UnboundLocalError: cannot access local variable 'validation' where it is not associated with a value\n\nbase\\apiutil.py:187: UnboundLocalError","steps":[],"attachments":[{"uid":"b98eed4979826195","name":"接口名称：根据课程ID查询课程","source":"b98eed4979826195.txt","type":"text/plain","size":26},{"uid":"aa28b317dc277fc2","name":"接口地址：http://47.115.225.121:8080/ssm_web/courseContent/findCourseByCourseId","source":"aa28b317dc277fc2.txt","type":"text/plain","size":26},{"uid":"133f67c8125f859b","name":"请求方法：GET","source":"133f67c8125f859b.txt","type":"text/plain","size":26},{"uid":"2e42ed48ba54f5a1","name":"请求头：{'Authorization': '0fdf0718-3e9a-48cc-bfcf-76549278f91f', 'Cookie': 'JSESSIONID=AB07D10EB3E10EF466525106650D493F'}","source":"2e42ed48ba54f5a1.txt","type":"text/plain","size":26},{"uid":"bd6f56daf4eb77f0","name":"测试用例名称：3.缺少courseId参数","source":"bd6f56daf4eb77f0.txt","type":"text/plain","size":26},{"uid":"80e85738f0516b80","name":"请求参数","source":"80e85738f0516b80.txt","type":"text/plain","size":14},{"uid":"b000f6b8b5bc0b7c","name":"接口响应原始内容","source":"b000f6b8b5bc0b7c.txt","type":"text/plain","size":840},{"uid":"b2ee19f919c62636","name":"log","source":"b2ee19f919c62636.txt","type":"text/plain","size":2140}],"parameters":[],"attachmentsCount":8,"shouldDisplayMessage":true,"attachmentStep":false,"stepsCount":0,"hasContent":true},"afterStages":[{"name":"start_test_and_end::0","time":{"start":1750810839059,"stop":1750810839059,"duration":0},"status":"passed","steps":[],"attachments":[],"parameters":[],"attachmentsCount":0,"shouldDisplayMessage":false,"attachmentStep":false,"stepsCount":0,"hasContent":false},{"name":"setup_fixture::0","time":{"start":1750810846938,"stop":1750810846938,"duration":0},"status":"passed","steps":[],"attachments":[],"parameters":[],"attachmentsCount":0,"shouldDisplayMessage":false,"attachmentStep":false,"stepsCount":0,"hasContent":false}],"labels":[{"name":"feature","value":"M04_课程管理"},{"name":"story","value":"C04_根据课程ID查询课程"},{"name":"tag","value":"run(order=11)"},{"name":"tag","value":"header_auth"},{"name":"tag","value":"smoke"},{"name":"tag","value":"course_query"},{"name":"tag","value":"api_single"},{"name":"tag","value":"course_management"},{"name":"parentSuite","value":"testcase.Single.CourseManagement"},{"name":"suite","value":"test_course_findbyid"},{"name":"subSuite","value":"TestCourseFindById"},{"name":"host","value":"SQG"},{"name":"thread","value":"19160-MainThread"},{"name":"framework","value":"pytest"},{"name":"language","value":"cpython3"},{"name":"package","value":"testcase.Single.CourseManagement.test_course_findbyid"},{"name":"resultFormat","value":"allure2"}],"parameters":[{"name":"base_info","value":"{'api_name': '根据课程ID查询课程', 'url': '/ssm_web/courseContent/findCourseByCourseId', 'method': 'GET', 'header': {'Authorization': '${get_extract_data(token)}', 'Cookie': '${get_extract_data(cookie)}'}}"},{"name":"testcase","value":"{'case_name': '3.缺少courseId参数', 'params': {}, 'validation': [{'neq': {'status_code': 200}}]}"}],"links":[],"hidden":false,"retry":false,"extra":{"severity":"normal","retries":[],"categories":[{"name":"Test defects","matchedStatuses":[]}],"tags":["api_single","course_management","header_auth","run(order=11)","smoke","course_query"]},"source":"733e24fdd9f2c81b.json","parameterValues":["{'api_name': '根据课程ID查询课程', 'url': '/ssm_web/courseContent/findCourseByCourseId', 'method': 'GET', 'header': {'Authorization': '${get_extract_data(token)}', 'Cookie': '${get_extract_data(cookie)}'}}","{'case_name': '3.缺少courseId参数', 'params': {}, 'validation': [{'neq': {'status_code': 200}}]}"]}